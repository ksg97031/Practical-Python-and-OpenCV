# Practical-Python-and-OpenCV


1장.
이미지 처리 및 컴퓨터 비전의 대한 소개 및 예제.


2장.
파이썩과 OpenCV 학습을 통한 이미지 처리 및 컴퓨터 비전의 대한 소개 및 예제.


3장.
CopyRight


4~5장.
목차 소개


6~7장.(서문)
처음 이 책을 작성하기 시작 했을 때 실습주도적으로 만들고 싶었습니다.
실습주도적으로 하기 위해 다양한 코드와 예제가 책에 포함되면 좋겠다고 생각하면서 만들었습니다.
만약 당신이 대학 수준의 수학, 컴퓨터 비전, 이미지 처리에 대한 이해 없이도 최대한 쉽게 학습할 수 있도록 제작했습니다.


대부분의 인생을 연구실에서 보내면서 보다 쉽게 프로그램을 열고 코드를 작성하게 만드는게 제일 좋은 교육임을 깨달았습니다.
제 책의 담겨져 있는 이론과 예제들은 경험상 분명한 시작점을 주었습니다.(?) 하지만 전 스스로 예제를 해볼 때까지 결코 배운적이 없습니다.(?)
그래서 전 무조건 직접 해봅니다. 이게 바로 이 책을 통해서 원했던 방식입니다. 모든 코드를 쉽게 수정할 수 있고 문서화가 잘 되어있어 당신이 맘대로 사용할 수 있습니다. 그게 바로 제가 모든 소스코드 리스트와 이미지를 사용하여 책을 작성한 이유입니다.


더 중요한건 전 이 책이 다양한 범주의 프로그래머들 또한 접근이 용이하길 원합니다.
처음 컴퓨터 비전을 공부 했을 때를 기억합니다. - 정말 주눅이 들게 하는 작업이지만 많은것을 배웠고 재밌었습니다.


전 당신이 컴퓨터 비전을 여행하는데 이 책이 도움이 되었으면 합니다. 만약 당신이 궁금한거나 질문이 있거나 혹은 간단하게 인사를 하고 싶다면 제 이메일 adrian@pyimagesearch.com 혹은 제 웹사이트인 www.PyImageSearch.com에 접속해서 내용을 남겨주세요. 당신의 소식이 금방 들리길 기대하겠습니다.


- Adrian Rosebrock


8장.(전제조건)


이것을 위해선 당신은 조금의 프로그래밍 경험이 필요할겁니다.
이 책의 모든 예제들은 파이썬 프로그래밍 언어로 되어 있습니다. 파이썬 혹은 다른 스크립트 언어들의 숙련도가 요구되지만 꼭 필요하진 않습니다.


또한 당신은 조금의 기초 수학 지식이 필요할겁니다. 이 책은 예제 주도 학습으로 되어 있습니다. 만약 당신이 수학 스킬이 기준 이하여도 걱정하지 마세요.
예제들은 굉장히 자세하고 어떻게 보면 심하게 문서화가 잘되어 있으니 당신 스스로 해낼 수 있을 겁니다.


9장.(책의 사용된 컨벤션(관습, 관례?))


이 책은 당신이 스스로 컴퓨터 비전과 이미지 처리를 배울 수 있도록 주도하는 다양한 코드가 포함되어 있습니다.


Italic

     노트를 해야할 만큼 주가 되는 용어나 정보일 경우나 수학적으로 함축적 의미에 방정식 또는 공식을 나타낼 수도 있습니다.


Bold


     노트를 해야할 만큼 중요한 정보.


Constant width


     소스 코드 목록과 함수 및 메소드 이름과 같은 소스 코드를 참조하는 단락에도 사용됩니다.


10장.(코드 예제 사용)


이 책은 컴퓨터 비전과 머신 러닝에 접근할 수 있도록 실습 주도를 할 생각이다. 이 책과 덧붙여 배포된 코드들은 당신이 원한다면 무료로 수정되고 탐구되며 공유되어도 상관없다.


일반적으론 당신은 이 책의 소스코드 사용에 대한 권한을 따로 요청 받지 않아도 되며, 이 책의 코드를 기반으로 작성되는 모든 스크립트는 전체적으로 허용됩니다.


그러나 이 책의 코드 리스트를 판매하거나 배포되는 행위 혹은 당신의 제품 정보나 제품 문서에 사용하는것은 내 권한을 요청해야합니다.


만약 당신이 합벅적으로 예제 코드를 사용하기 위해서 제발 제게 이메일을 주시길 바랍니다. adrian@pyimagesearch.com 으로 연락주시면 됩니다.


11장.(연락 방법)


나를 온라인에서 찾고 싶으세요? 더 이상 멀리 찾지 마세요.


Website: www.PyImageSearch.com
Email: adrian@pyimagesearch.com
Twitter: @PyImageSearch
Google+: +AdrianRosebrock
LinkedIn: Adrian Rosebrock


본문 1장.(소개)


컴퓨터 비전의 목표는 사진속의 스토리를 이해하는거 입니다.
사람으로써 이것은 매우 쉬운 일입니다. 하지만 컴퓨터로서 이 작업은 극도록 어렵습니다.


그러면 왜 컴퓨터 비전을 같이 배워야 할까요?


음, 이미지들은 어디에서 있으니깐!


당신의 스마트폰의 있는 사적인 사진들이라던가 페이스북의 공개된 사진들 혹은 유투브 비디오, 우린 지금 수 많은 이미지들을 가지고 있습니다. 그리고 우리는 이 이미지들을 분석하고, 분리하고, 수량화하는 방법이 필요합니다.


한 예로 최근의 페이스북에 당신이나 친구들이 태그된게 있습니가? 페이스북은 어디서 이미지속의 얼굴들이 어디있는지 알 수 있을까요?


페이스북은 얼굴 인지 알고리즘을 자신들의 웹사이트에 구현했습니다. 이 말은 그들은 단지 이미지속의 얼굴들만을 찾는다는 예기는 아닙니다.
그들은 누구의 얼굴인지 구분도 굉장히 잘합니다. 얼굴 인식이 사용된 어플리케이션이 바로 컴퓨터 비전의 현재입니다.


본문 2장.


컴퓨터 비전을 사용하는 다른 용도의 유용한 어플리케이션이 뭐가 있을까?


좋다, 우리는 Flickr 같은 저장소의 무료 이미지를 사용해서 3D 월드를 묘사하는걸 만들수 있었다.
시민들이 스마트폰으로 찍은 맨해튼에 수천장의 사진들을 다운로드하여 분석하고, 정리해서 3D로 맨해튼을 표현할 수 있었다.
또한 이를 통해 이 도시의 가상 안내자를 만들것이다. 멋지지 않은가?


또 다른 유명한 컴퓨터 비전 기능은 감시다.


감시를 하는건 부정적인 경향이 내포되어 있긴 하지만 다른 종류의 감시도 많다.
하나의 종류로 말을하면 보안 비디오들을 분석하는 행위와 관련돼있다. 강도 사건 이후 가능한 일을 생각해봐라.


하지만 소매점에서는 다른 종유릐 감시를 볼 수 있다. 백화점에서 조정된 카메라(?)를 사용해서 당신의 이동 경로와 어느 가계들을 돌아다녔는지, 어느 키오스크에서 멈추었는지를 알 수 있다.


너가 제일 좋아하는 의류 가계를 마지막으로 방문했다 가정하면, 고객은 봄의 최신 트랜드 진을 보고 있는지?
얼마나 많이 청바지를 봤는지? 청바지를 봤을 때 고객의 얼굴은 어떠했는지? 상품을 들고 드레스 룸으로 향했는지?
이 모든 질문을 모두 대답할 수 있는게 바로 컴퓨터 비전 중 하나인 감시 시스템입니다.

본문 3장.


컴퓨터 비전은 의학 필드에서도 사용되고 있다.
제 작년에 국립 암 연구소에서 유방 조직 이미지를 통한 암 유발 원인 조사를 자동화하는 개발 방법에 대해서 컨설팅을 한 적 있다.
일반적으로 이런 작업은 수년의 경험으로 훈련된 병리학자들이 필요하다. 그리고 이것은 굉장한 시간이 소비될 것입니다.!


우리는 컴퓨터 비전 알고리즘을 이미지들의 접목시켜 자동적으로 세포 구조를 분석하고, 정량화하는걸 목적으로 연구했다. - 사람의 간섭없이!
그리고 현재 우리는 유방 조직 이미지를 통해 암 유발 원인들을 훨씬 빨리 분석 할 수 있게 됐다.


그래 맞다. 컴퓨터 비전은 다른 의학 필드에서 사용될 수 있다. 컴퓨터 비전 알고리즘을 사용해서 X-Rays, MRI 스캔, 세포 조직 분석 모든걸 할 수 있다.


 아마 최고의 컴퓨터 비전 성공 스토리는 X-Box 360 Kinect로 들었을수도 있다. Kinect은 스테레오 카메라를 이용해서 이미지의 깊이를 이해할 수 있고 , 사람의 포즈를 인식하고 분류할 수 있으며, 머신 러닝에도 도움을 주었다. 당연하게도.


이뿐만이 아니다.


컴퓨터 비전은 당신이 인지 하든 못하든 당신의 삶속 모든 장소에 있다. 우리는 컴퓨터 비전 알고리즘을 제공해서 영화나 축구 게임, 행동 인식(수화를 위해), 인가 번호판(당신이 운전을 매우 빠르게 했을 때), 의한, 수술 군대, 소매점 등에 적용될 수 있다.


본문 4장.


우리는 심지어 컴퓨터 비전을 우주에서까지 사용한다.! 나사의 Mars Rover는 행성의 지형을 모델링하는 기능이 포함되어 있으며, 이동 경로에 장애물을 인지하고 파노라마 이미지들을 모두 스티치(?)할 수 있다.


이러한 목록은 앞으로 계속 성장해 나갈거다.


확실히 컴퓨터 비전은 끝도 불가능도 없는 매력적인 분야이다.


이러한 생각을 가지고 당신 스스로에게 질문해보자, 당신의 상상으로 무엇을 만들고 싶은가?
만들어보자 그리고 컴퓨터 비전 기술을 소개하는 이 책을 통해 성장해보자.


본문 5장. (파이썬 그리고 필요한 패키지들)


컴퓨터 비전을 탐구하기 위해서는 우린 먼저 몇몇의 패키지들을 설치해야한다. 컴퓨터 비전의 첫번째 시간은 자신이 사용할 운영체제 환경에 맞는 패키지들을 설치하는거이며 좀 지루할 수 있는것들이다. 내가 이미 설치와 관련된 설명서를 작성 해놨지만 당신도 알다시피 프로젝트가 바뀌고, 웹사이트가 변경되고, 설치 설명들이 변경된다.! 만약 당신에게 문제가 있다면 패키지들의 최근 설치 설명서를 찾아봐라.


나는 easy_install 혹은 pip를 통해 당신의 패키지를 설치하고 관리하는걸 굉장히 추천한다. 이것이 당신의 삶을 더 쉽게 만들것이다.


마지막으로 만약 당신이 이 패키지들을 설치하는걸 원하지 않을거 같아 우분투 가상머신에 패키지들을 미리 설치해놨다. 가상 머신을 사용해서 패키지 매니저, 설치 가이드, 컴파일러 에러 없이 이 책의 예제들을 직접 체험해 볼 수 있다.


본문 6장.


가상 머신 설치를 위한 이전 과정에 대한것들을 http://www.pyimagesearch.com/practical-python-opencv/에서 볼 수 있다.
그러면 패키지들을 설치해보자!.


     2.1 NUMPY AND SCIPY


     NumPy는 파이썬 프로그래밍 언어에서 큰 다차원 배열을 제공하는 라이브러리다.
     이게 왜 중요할까? NumPy를 사용하면 이미지를 다차원 배열로 표현할 수 있다. 이미지를 NumPy 배열형으로 함으로써 계산 및 리소스 효율적이게 된다. 뿐만 아니라 NumPy의 작성된 수준 높은 수학 함수들, 우리는 이미지를 수치적으로 빠르기 분석할 수 있게 된다.


     NumPy와 마찬가지로 우리는 SciPy 또한 필요합니다. SciPy는 과학적이고 컴퓨터 기술에 대한 추가 지원을 합니다.


     2.1.1 Windows


     단연코 가장 쉽게 NumPy와 SciPy를 당신의 윈도우에 다운로드 할 수 있는 방법은 이곳에서 배포된 바이너리를 다운 받는거입니다. : http://www.scipy.org/install.html




본문 7장.


     2.1.2 OSX


     만약 당신이 OSX 10.7.0 (Lion) 혹은 그 이상을 사용하고 있으면 NumPy와 SciPy는 이미 사용중일겁니다.


     그러나 나는 ScipySuperpack을 설치하는걸 좋아합니다. 이건 마지막 버전의 NumPy, SciPy, Matplotlib 그리고 다른 외부 유용한 패키지들 예로 ipython pandas 그리고 scikit-learn을 포함하고 있습니다.
     이 모든 패키지들은 설치할 가치가 있는 패키지들이며 만약 당신이 내 블로그 www.PyImageSearch.com을 구독했으면 내가 이 라이브러리를 자주 사용한다는것을 알고 있을겁니다.


     2.1.3 Linux


     대다수의 리눅스 배포판인 우분투에서는 NumPy가 이미 설치되어 있습니다.


     만약 마지막 버전의 NumPy와 SciPy 설치를 원한다면 당신은 라이브러리 소스를 빌드하는 방법이 있습니다. 하지만 제일 쉬운 방법으로는 apt-get 같은 패키지 매니저를 사용하는법입니다.


     2.2 MATPLOTLIB


     쉽게 넣는다, matplotlib는 플로팅 라이브러리입니다. 만약 당신이 MATLAB을 이전의 사용을 해봤다면 아마 당신은 굉장히 편안한 느낌을 matplotlib 환경에서 느낄수 있을겁니다. 이미지를 분석할 때 matplotlib을 사용할겁니다. 이미지들의 막대 그래프를 플로팅하든지 이미지를 쉽게 보여주기 위해서 matplotlib은 굉장히 훌튱한 툴입니다.


본문 8장.


     2.2.1 All Platforms


     Matplotlib은 여기에 있습니다. http://matplotlib.org/ 만약 이미 ScipySuperpack이 설치되어 있으면 Matplotlib도 깔려 있을겁니다.
     혹은 pip나 easy_install을 사용해 설치할 수도 있습니다.


     다른 방법으로는 윈도우용으로 제공되는 설치 프로그램을 이용하면 됩니다.


     2.3 OPENCV


     만약 NumPy의 목표가 큰, 효율적인, 다차원 배열을 표현하는거면 OpenCV의 목표는 실시간으로 이미지를 처리하는거다.
     이 라이브러리는 1999년쯤 나왔다. 하지만 믿을수 없게 2009년 출시된 2.0 버전에부터 NumPy를 지원하는걸 볼 수 있었다.
     OPENCV 라이브러리는 C/C++로 작성됐지만 실행하고 설치될 때는 파이썬을 바인딩해서 제공됩니다. 이것은 손을 덜어주는 내가 제일 좋아하는 컴퓨터 비전 라이브러리이며, 이 책에서 굉장히 많이 사용할 것입니다.


     OpenCV 설치는 끊임없이 변경됩니다. C/C++로 라이브러리가 작성됐을 때 특별 관리를 통한 컴파일이거나 이전 조건이 꼭 보장되어야만 설치가 됐습니다. 확실히하고 가기 위해서 http://opencv.org/ 웹사이트를 확인바랍니다. 가장 최신의 설치 설명서가 그들의 작업에 따라 미래에 계속 변경될 겁니다.


본문 9장.


     2.3.1 Windows and Linux

     OpenCV 문석에는 윈도우와 리눅스에서 배포된 바이너리를 통해 OpenCV를 설치하는 환상적인 튜로리얼이 제공됩니다.
     아래의 설치 설명서를 확인하세요: http://docs.opencv.org/doc/tutorials/instroduction/table_of_content_introduction/table_of_content_introduction.html#table-of-content-introduction.


     2.3.2 OSX


     과거에 OpenCV를 OSX에 설치하는건 굉장히 괴로운 작업이였습니다. 하지만 행운이게도 brew를 통해서 훨신 설치가 쉬어졌습니다.
     다음 주소로 가서 OSX의 패키지 매니저인 brew를 다운로드하세요. http://brew.sh/ 이 또한 당신의 삶을 더 풍족하게 해줄겁니다.


     만약 brew가 설치됐다면 당신은 앞에 나올 간단한 명령어만 있으면 됩니다. 일반적으로 내가 찾은 OpenCV on OSX에 Jeffery Thompson's 설명이 경이적이고 훌륭한 출발점이 될 겁니다.


     설명문은 여기서 확인할 수 있습니다. : http://www.jeffreyt-hompson.rog/blog/2013/08/22/update-installing-opencv-on-mac-mountain-lion/.


     2.4 MAHOTAS


     Mahotas, OpenCV와 마찬가지로 NumPy 배열을 사용합니다. Mahotas의 구현된 기능들 대부분은 OpenCV에서 찾을 수 있지만,


본문 10장


      몇개의 케이스에서 Mahotas 인터페이스를 사용하는게 더 쉬워서 OpenCV를 보완하기 위해 우리는 Mahotas를 사용합니다.


     2.4.1 All Platforms


     Mahotas를 모든 플랫폼에 설치하는건 매우 쉽습니다. NumPy와 SciPy가 설치되어 있다고 가정하며, 당신은 pip install mahotas 혹은 easy_install mahotas만 하면 됩니다.


     만약 이 모든 패키지들이 설치가 완료 됐으면 지금부터 컴퓨터 비전 세계의 탐험을 시작합시다.


     2.5 SKIP THE INSTALLTION


     내가 이미 언급했다 시피, 패키지들을 설치하는 과정은 굉장히 소비적이고 지루한 시간입니다. 만약 이 모든 설치 과정을 넘기고 싶고 이미지 프로세싱과 컴퓨터 비전 세계로 지금 바로 오고 싶으면 미리 모든 패키지들을 설치해 준비한 우분투 가상 머신을 사용하세요.


     만약 가상 머신이 흥미롭고 다운로드 하고 싶으면 다음의 주소로 가면 됩니다. : http://www.pyimagesearch.com/practical-python-opencv/




본문 11장. (로딩, 출력, 저장)


이 책은 파이썬과 OpenCV를 이용한 실습 주도적 컴퓨터 비전 가이드를 목표로 하고 있습니다.
이 말은 즉, 필요 없는 시간이 없다는 겁니다. 자 그럼 디스크속 이미지를 간단한 코드로 로드해서 화면에 띄우고 다른 포맷으로 변경함으로써 발을 적셔봅시다.
실행될, 화면에 이미지를 띄어줄 우리의 파이썬 스크립트는 그림 3.1에 있습니다.


첫 번째로 load_display_save.py라는 이름으로 파일을 생성하고 아래의 코드를 작성해 봅시다.


import argparse
import cv2


ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", required = True,
    help = "Path to the image")


args = vars(ap.parse_args())

제일 먼저 생각해야 하는건 우리가 이 예제에 필요한 페키지들을 모두 불러오는겁니다.
우리는 argparse를 이용해 커맨드라인의 인자를 파싱하여 처리할겁니다. 그 다음에 cv2가 불러왔습니다. cv2는 우리의 OpenCV 라이브러리이며


본문 12장.


그림 3.1:티라노사우르스(티라노사우루스 이미지를 우리 화면의 띄었습니다.)


이미지 처리 함수들이 정의되어 있습니다.


    줄 4-7을 보면 커맨드 라인을 통해 인자를 파싱해서 처리하는 코드가 있습니다. 지금은 단 --image: 디스크속 이미지 경로, 옵션 하나만 필요합니다.
마지막으로 인자들을 파싱하고 폴더에 이것들을 저장합니다.




image = cv2.imread(args["image"])
print("width: %d pixels" % (image.shape[1]))
print("height: %d pixels" % (image.shape[0]))
print("channels: %d" % (image.shape[2]))


cv2.imshow("Image", image)
cv2.waitKey(0)




본문 13장.


이제 우린 디스크의 저장된 이미지 경로를 cv2.imread 함수(Line 8)를 이용해 로드합니다. cv2.imread 함수는 이미지를 표현한 NumPy 어레이를 반환합니다.


Lines 9-11 이미지의 크기를 조사합니다. 다시 언급하면 이미지는 NumPy 어레이로 표현되어 있습니다. 우리는 넓이, 높이, 채널을 조사하여 도형 속성을 통해 쉽게 가져올 수 있습니다.


마지막으로 Lines 13 and 14 처리를 통해 실제의 이미지를 화면에 출력해줍니다. 첫번째 파라미터는 문자열로 윈도우의 이름을 명시합니다.
두번째 파라미터는 디스크에서 로드한 이미지 데이터입니다. 마지막으로 cv2.waitKey 호출을 통해서 특정 키를 입력하기 전까지 스크립트 실행을 중지시킵니다. 파라미터 0을 표시함으로써 아무런키나 입력해도 실행중지가 풀립니다.


마지막으로 이미지를 jpg 형식으로 변경해 봅시다.


cv2.imwrite("newimage.jpg", image)


모든 과정을 마친 후 첫번째 경로로 두번째 인자의 이미지를 저장할 수 있습니다. 정말 쉽습니다.


우리의 스크립트를 실행해보고 이미지를 출력해봅시다. 우리는 손 쉽게 터미널창을 열어서 아래의 명령어로 실행할 수 있습니다.




본문 14장.


$ python load_display_save.py --image ../images/trex.png


만약 모든 작업이 정상적으로 됐으면 당신은 T-Rex를 그림 3.1 처럼 화면에서 확인할 수 있을겁니다.
또한 넓이 350 pixels, 높이 228 pixels 그리고 채널 3 channels (RGB 구성 이미지)로 표시 될겁니다.
NumPy 어레이로 표시된 우리 이미지의 형태는 (350, 228, 3) 입니다.


우리가 행렬들을 작성할 때 흔한 형식에 맞춰서 작성했습니다.(# 행 X 열) - 이것은 NumPy의 형식이 아닙니다.
NumPy는 실제로 행과 열의 수를 제공해주고 있습니다. 이것은 매우 중요한것입니다.


마지막으로 당신의 디렉터리를 확인해보면 새로운 파일인 newimage.jpg가 있을겁니다.
OpenCV는 자동적으로 PNG 이미지를 JPG로 우리를 위해 형변환 해줍니다.!
더 이상 어렵게 이미지 포맷을 변경하지 않아도 됩니다.


다음 차례에서는 우리는 어떻게 이미지 픽셀 값들에 접근하고 조종할 수 있는지 탐험해보겠습니다.




본문 15장. (이미지 기초)


이번 챕터에서는 이미지의 구성 요소를 검토할 것입니다. - 픽셀.


우리는 픽셀이 무엇인지에 대해서, 어떻게 픽셀이 이미지를 형성할 수 있는지, 어떻게 OpenCV를 사용해 픽셀에 접근하고 조정할 수 있는지 확실히 논의할 것입니다.


4.1     SO, WHAT'S A PIXEL?


모든 이미지는 일련의 픽셀들로 이루어져 있습니다. 픽셀은 이미지의 구성 요소 중 가장 기본입니다.
픽셀보다 작은 단위에 세부적인 요소는 없습니다.


일반적으로 우리는 픽셀이 이미지의 색상이나 빛의 강도를 나타낼거라고 생각합니다.


만약 당신이 생각하기에 이미지가 격자 무늬로 되어 있으면 각 픽셀에 격자 무늬 모양이 포함되어 있습니다.


한가지 예로, 우리가 500 X 300 크기의 이미지를 가지고 있다고 생각해 봅시다. 이 말은 이미지가 격자 무늬의 픽셀들로 500 행과 300열로 구성되어 있다는겁니다. 결과적으로 이미지에는 500 X 300 = 150,000의 픽셀이 존재합니다.




본문 16장.


대부분의 픽셀은 두가지 방법으로 표현됩니다. 흑백 그리고 컬러.
흑백 이미지를 먼저 말하면, 각 픽셀은 0에서 255 사이의 값을 가지고 있으며 그 중 0이 바로 "흑" 255가 "백"과 일치합니다.


0에서 255 사이의 값들은 다양한 회색 음영이며, 0에 가까울수록 어둡고, 255에 가까울수록 밝아집니다.


컬러 픽셀은 일반적으로 RGB 컬러 공간으로 표현됩니다.
하나의 값은 빨간 요소, 다른 하나는 초록, 파랑. 다른 컬러 공간도 존재하지만 여기선 기본적인것만 배우고 넘어가도록 하겠습니다.


RGB 세가지 색상은 정수 0에서 255 사이의 값으로 표현되며, 이는 색상의 정도를 나타냅니다. 픽셀 밸류에는 오직 0에서 255값만 필요하기 때문에 우리는 일반적으로 8비트 양의 정수값만을 컬러의 정도를 표시하는데 사용합니다.


우리는 세개의 값을 RGB 형식의 튜플로 묶어서 (red, green, blud). 이 튜플값으로 색상을 나타냅니다.


흰색을 만들기 위해서는 빨강, 초록, 블루 버킷을 다음과 같이 완전히 채우면 됩니다.: (255, 255, 255).


그다음 블랙 컬러를 만들고 싶으면 모든 버킷을 비우면 됩니다. : (0, 0, 0)


순전히 빨간 색상을 만들기 위해서는 빨간 버킷만 채우고 다른곳은 완전히 비우면 됩니다.: (255, 0, 0).


이제 패턴을 확인해볼까요?




본문 17장.


다음은 참고 자료입니다. 흔히 사용하고 있는 값을 RGB 튜플값으로 나타냈습니다.


• Black: (0,0,0)
• White: (255,255,255)
• Red: (255,0,0)
• Green: (0,255,0)
• Blue: (0,0,255)
• Aqua: (0,255,255)
• Fuchsia: (255,0,255)
• Maroon: (128,0,0)
• Navy: (0,0,128)
• Olive: (128,128,0)
• Purple: (128,0,128)
• Teal: (0,128,128)
• Yellow: (255,255,0)


이제 우리는 픽셀에 대해 알아봤습니다. 그럼 이제 빠르게 좌표계를 배우도록 하겠습니다.




본문 18장.


4-2 좌표계의 개요


위에서 언급한것 처럼 이미지는 격자무늬에 픽셀로 구성되어 있습니다.
격자무늬를 그래프 용지의 조각으로 상상해보세요. 이 그래프 용지를 사용해서 (0,0) 위치는 이미지의 왼쪽 위 코너와 일치합니다.
만약 우리가 아래와 오른쪽으로 움직이면 x, y 값이 모두 증가합니다.


자 그럼 그림 4.1를 한번 확인해보세요. 훨씬 더 이해가 깔금하게 될 겁니다.


여기 우리가 I라는 글자를 그래프 용지의 조각들로 가지고 있습니다. 우리는 8 x 8의 격자무늬로 총 64 픽셀을 가지고 있습니다.


(0,0) 위치는 이미지의 왼쪽 위와 일치하고 반면에 (7,7) 위치는 오른쪽 하단 코너와 일치합니다.


마지막으로 (3,4) 위치는 3행 4열과 일치합니다, 한번 더 1 대신 0을 출발점으로 생각합니다.


여기서 1 대신에 0으로 계산하는건 굉장히 중요합니다. 파이썬 언어에서는 0이 기준 첨자입니다.
이 말은 즉, 우리는 항상 0부터 시작해야한다는 겁니다. 추후에 여러 문제가 생기지 않게 이 요점을 잘 간직하세요.


4-3 픽셀의 접근 및 조정


인정하게도 챕터 3의 예제들은 흥미롭지 않다. 우린 그저 디스크에서 이미지를 로드하고


본문 19장.


그림 4.1: 문자 I가 각 조각의 그래프 용지의 표시되어 있습니다. 픽셀은 (x,y) 좌표를 통해 접근할 수 있습니다. 파이썬은 0부터 시작하는 인덱스 방식임을 잊지 말아야한다: 우리는 1이 아닌 0부터 인덱스를 세워야한다.




본문 20장.


다른 이미지 포맷으로 디스크에 작성하는 작업을 했다.


이제 조금은 다른 재밌는 짓을 해보자 그리고 어떻게 이미지속 픽셀에 접근하고 조정하는지 알아보자.


import argparse
import cv2


ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", required = True,
    help = "Path to the image")


args = vars(ap.parse_args())


image = cv2.imread(args["image"])
cv2.imshow("Original", image)


 이전 챕터와 비슷하게 Lines 1-7은 패키지를 임포트하고 인자 파서에 따라 세팅을 해야합니다.
저기에는 단 한 줄에 커맨드 명령어와 인자가 필요합니다.( 인자로는 작업을 할 이미지의 경로 )


Lines 9 and 10은 이미지를 실질적으로 로드하고 출력해주는 부분입니다.


그럼 이미지가 로드가 됐으면 우리는 어떻게 실제 픽셀 벨류를 확인할 수 있을까요?


기억해보자, OpenCV는 NumPy 배열을 통해 이미지를 표현해줍니다. 위의 섹션 4.1의 토론을 통해 우리는 개념적으로 배열을 생각할 수 있습니다.
픽셀 밸류에 접근하기 위해서는 흥미롭게도 우리는 단지 x, y 픽셀에 대한 좌표만 필요합니다. 거기서부터 우리는 빨강, 초록, 파랑 요소들의 튜플 정보를 줘야합니다.


본문 21장.


그러나 중요한 사실은 OpenCV는 RGB 채널을 거꾸로 저장합니다. 일반적인 RGB 용어대로 저장되면 빨강, 초록, 파랑 순서지만 OpenCV에서 실질적으로 파랑, 초록, 빨강 순서로 저장이 됩니다. 이것은 매우 중요한 부분입니다. 이와 관련해서는 추후 따로 언급하겠습니다.


자, 이제 픽셀에 접근하고 조정할 수 있는 몇개의 코드를 보도록 합시다.


(b, g, r) = image[0, 0]
print("Pixel at (0, 0) - Red: %d, Green: %d, Blue: %d" % (r, g, b))


image[0, 0] = (0, 0, 255)
(b, g, r) = image[0, 0]
print("Pixel at (0, 0) - Red: %d, Green: %d, Blue: %d" % (r, g, b))


Line 11을 보면 (0,0) 위치에 픽셀을 잡고 있습니다. - 이미지의 가장 왼쪽 최상단 코너
이 픽셀은 튜플 형식으로 표현됩니다. 다시 한번 OpenCV에 저장되는 RGB 픽셀은 순서가 반대입니다. 그래서 이 튜플을 언팩할 때는 위에 (b, g, r) 순서로 해야지 RGB를 확인할 수 있습니다. 그 다음 Line 22를 보면 각 채널의 밸류를 콘솔에 출력해주고 있습니다.


당신도 봤다 싶이 픽셀 값에 접근하는것은 굉장히 쉽다.! NumPy는 모든 어려운 일을 처리해준다. 어레이를 인덱스로 접근하는걸 제공함으로써 모든 행동을 가능하게 해준다.


NumPy는 픽셀 밸류를 쉽게 접근하는것뿐만 아니라 픽셀 값을 쉽게 다룰 수 있게 해준다.


본문 22장.


Line 14를 통해서 가장 왼쪽 최상단(0,0)에 있는 이미지의 픽셀을 다루어 (0, 0, 255) 값으로 설정해보자.
만약 픽셀 밸류를 RGB 포맷으로 읽게 된다면 우리는 0을 빨강, 초록 그리고 255을 파랑으로 표현하여 순전한 파란색을 만들것이다.


그러나 위에 언급한거 같이 우리는 OpenCV의 특별한 처리가 필요하다. 우리의 픽셀들은 실질적으로 RGB 포맷이 아닌 BGR 포맷이다.


우리는 실질적으로 파랑이 아니라.. 빨강 255, 초록 0, 파랑 0으로 읽혔다.


왼쪽 최상단 픽셀을 세팅하고나서 픽셀에 밸류를 15, 16 라인을 통해 확인해봤을때 우리는 그저 정말 픽셀 색상 변경에 성공했는지 확인만하면 됩니다.


각각의 픽셀 값을 접근하고 설정하는건 충분히 쉽습니다. 하지만 만약 이미지의 큰 부분으로 사각형으로 NumPy 어레이를 통해 자르는 능력을 원한다면?
아래 코드가 바로 자르는 방법입니다.


corner = image[0:100, 0:100]
cv2.imshow("Corner", corner)


image[0:100, 0:100] = (0, 255, 0)


cv2.imshow("Updated", image)
cv2.waitKey(0)


17라인을 보면 우리는 이미지의 100 x 100 픽셀 영역을 자르고 있습니다.
사실 이게 바로 이미지의 왼쪽 상단 모서리 부분입니다! 이미지의 픽셀 덩어리를 잡기 위해서 NumPy는 4개의 인덱스를 요구합니다.


본문 23장.


1. Start y: 가장 첫 번째 y 좌표입니다. 맨 처음은 y축을 따라 시작합니다. 위 예제에 따르면 우리는 y = 0 부터 자르길 시작합니다.
2. End y: 시작 y 값을 제공을 이미 했으니 자르는 마지막 y 값을 제공해야만 합니다. 예제에서는 y축 100을 나타내고 있습니다.


3. Start x: 세번째 밸류, 이미지를 자를 x 좌표입니다. 좌측 최상단을 자르기 위해 x축은 0으로 정의합니다.


4. End x: 마지막으로 x축에 마지막 범위를 입력해야합니다. 예제에서는 x = 100으로 표시하고 있습니다.


한번 이미지의 좌측 최상단 코너 부분을 추출해봤습니다, Line 18 보이는게 바로 잘린 부분입니다.
해당 이미지는 원본 이미지에 좌측 최상단 100 x 100 픽셀 영역에 불과하다는 것에 주목하세요.


마지막으로 우린 이 잘라진 어레이를 이용해서 해당 픽셀 영역에 색상을 변경해보도록 할겁니다. 20번째 줄에서 우리가 다시 이미지의 왼쪽 코너를 다시 접근하는것을 볼 수 있습니다. 그러나 이번에는 이 영역을 녹색으로 설정하겠습니다.


22, 23번째 줄에서 결과가 보여집니다.


그러면 우리가 어떻게 파이썬 스크립트를 실행할 수 있을까요?


당신이 생각한데로 이 책에서 다운로드한 소스 코드들 중 쉽게 chapter-04 디렉터리로 가서 아래의 명령어를 이용해서 실행시킬 수 있습니다.




본문 24장.


Listing 4.4: getting_and_setting.py
$ python getting_and_setting.py --image ../images/trex.png


만약 이 스크립트가 당신의 콘솔에서 실행이되면 화면에 결과가 출력될겁니다.(12번째 줄)
출력문의 첫번째 라인은 RGB 채널이 포함된 픽셀의 위치를 말해주고 있습니다. 이 픽셀의 대부분은 하얀색일겁니다.


두번째 출력문은 흰색 대신 빨간색이 들어간 완전히 변경된 픽셀(0,0)을 보여줍니다. (14~16번째 줄)


Listing 4.5: getting_and_setting.py


Pixel at (0, 0) - Red: 254, Green: 254, Blue: 254
Pixel at (0, 0) - Red: 255, Green: 0, Blue: 0


그림 4.2를 보면 결과물을 확인할 수 있습니다. 상단-좌측 이미지가 원본 이미지이고, 상단-우측 이미지가 100 x 100 픽셀로 잘린 이미지입니다.
그리고 자세히보면 왼족 상단 픽셀(0,0)이 빨간색인걸 볼 수 있습니다.!


마지막으로 아래 이미지는 초록 사각 모양으로 성공적으로 그려진 이미지를 확인할 수 있습니다.


이번 챕터에서는 NumPy의 어레이 자르기 기능들을 통해 어떻게 픽셀을 접근하고 다룰 수 있는지 탐험할 수 있엇습니다.


본문 25장.


그림 4.2


본문 26장.


우리는 녹색 도형을 NumPy 어레이 조작만으로 그릴 수 있게 됐습니다!


그러나 우린 단지 NumPy 함수들만 사용해서 멀리가는걸 원하지 않습니다. 다음 챕터에서는 어떻게 선과 삼각형, 원을 OpenCV 메소드로 그릴 수 있는지 보여줄겁니다.




본문 27장.(그리기)


챕터 4에서 NumPy를 이용해서 어레이를 자르는 행동을 통해 녹색 사각 도형을 이미지의 그리는걸 해봤습니다.
하지만 만약 우리가 라인 하나를 그리길 원한다면? 혹은 원이나? NumPy에서는 그런 종류의 기능들을 지원하지 않습니다. - 이건 오직 수치 계산 라이브러리일 뿐입니다!


운 좋게 OpenCV에서 이미지의 도형을 그리는 쉬운 메소드 사용을 통해서 이러한 편의를 제공합니다.
이번 챕터에서는 세개의 기본적인 도형을 그릴 수 있는 메소드를 확인해볼겁니다. : cv2.line, cv2.rectangle, cv2.circle


이 챕터는 완벽하고 철저하게 OpenCV의 그리기 능력의 요약은 결코 아니지만, 이것은 그래도 직접 빠르고, 즉각 그림을 그릴 수 있게한다.e


5.1 선그리고 직사각형


OpenCV의 드로잉 능력들을 탐구하기 이전에 우리는 먼저 걸작을 그릴 켄바스를 정의해야 합니다.




본문 28장


이 위치까지 이르기까지, 우리는 이미지를 디스크에서 로드했다. 그러므로 메뉴얼대로 NumPy 어레이를 이용해서 이미지를 정의할 수도 있었다.
제공된 OpenCV의 설명으로 이미지를 NumPy 배열로서 표현하는것은 방법이 없다. 왜냐하면 우리는 이미지를 우리 맘대로 정의할 수 없기 때문이다!


우리의 이미지를 초기화하기 위해서 아래의 코드를 실시하자.


import numpy as np
import cv2


canvas = np.zeros((300, 300, 3), dtype = "uint8")


줄넘버 1, 2는 사용할 패키지를 임포트한다. 간단하게 numpy를 np라는 이름으로 재명칭한다. 이러한 규칙은 나머지 책 모두 지속적으로 적용될거다.
사실 이러한 규칙은 파이썬 커뮤니티에서 보는게 좋다! 우리는 또한 cv2를 임포트 함으로써 OpenCV 라이브러리에 접근할 수 있게 됐다.


줄넘버 4로 처리해서 이미지를 초기화한다. 우리는 np.zeros 메소드를 사용해서 300 행과 300 열의 NumPy 배열을 구축할 수 있다.(300 x 300 픽셀에 이미지) 또한 우리는 R, G, B 자리로 예상되는 3 채널 공간을 할당한다. 명시된 이름처럼 zeros 메소드는 배열 모든 요소의 값을 zero로 초기값을 채웁니다.


당신의 흥미에 따라서 두번째 메소드에 인자를 전달하는게 중요합니다. np.zeros 메소드의 dtype은 데이터 타입을 의미합니다. 현재 우리는 0~255 사이의 RGB 이미지를 픽셀로 표현하기 때문에 양의 정수 혹은 양의 정수로 8바이트를 사용하는게 바람직합니다. 여기에는 사용 가능한 다양한 여러 타입들이 존재합니다.(흔하게 32비트 정수와 32, 64비트 실수들이 있습니다.)






본문 29장.


하지만 이 책에서 우리는 주로 uint8를 사용합니다.
아래는 우리가 그림을 그리기 위해 초기화된 켄바스입니다.


green = (0, 255, 0)
cv2.line(canvas, (0, 0), (300, 300), green)
cv2.imshow("Canvas", canvas)
cv2.waitKey(0)


red = (0, 0, 255)
cv2.line(canvas, (300, 0), (0, 300), red, 3)
cv2.imshow("Canvas", canvas)
cv2.waitKey(0)


5번째 줄에 정의된 튜플은 녹색으로 사용됩니다. 그 다음 6번째 줄을 보면 0,0 좌표에서 (좌측 상단 코너)에서 300, 300 좌표로 녹색 선을 그립니다.


선을 그리기 위해 우리는 cv2.line 메소드를 주로 사용합니다. 이 메소드에 첫번째 인자는 우리가 이미지를 그릴 곳입니다. 위 예제에서는 canvas입니다. 두번째 인자는 라인의 시작점입니다. 우리는 좌측-상단 코너를 시작 지점으로 정했습니다. 우리는 마지막으로 선의 목적지점이 필요합니다. 바로 세번째 인자가 바로 마지막 지점입니다. 이 예제에서는 (300, 300)이 됩니다.
마지막 인자는 바로 라인의 색상입니다. 이 예제에서는 녹색으로 설정됐습니다. 줄넘버 7~8은 이미지를 보여주고 키 입력을 대기하는 부분입니다.




본문 30장.


그림 5.1: OpenCV를 통해 작성한 직사각형과 선들입니다.


당신도 알다 싶이 라인을 그리는건 굉장히 쉽습니다! 하지만 cv2.line의 또 다른 인자가 굉장히 중요합니다. 바로 두께입니다.


줄넘버 10-13을 보면 빨간 컬러의 튜플이 정의되어 있습니다. 그 다음 빨간 선을 오른쪽 코너에서 왼쪽 아래 코너로 선을 그었습니다. 여기서 가장 마지막 파라미터는 선의 두께를 명시합니다. 우린 두께를 3 픽셀로 설정했습니다. 다시 한번 이미지를 보여주고 키 입력을 대기합니다.


라인을 그리는건 충분히 간단합니다. 그럼 이제 직사각형을 그리는걸로 넘어갑시다. 아래의 코드를 잘 살펴봐주세요.




cv2.rectangle(canvas, (10, 10), (60, 60), green)
cv2.imshow("Canvas", canvas)
cv2.waitKey(0)


cv2.rectangle(canvas, (50, 200), (200, 225), red, 5)
cv2.imshow("Canvas", canvas)
cv2.waitKey(0)


blue = (255, 0, 0)
cv2.rectangle(canvas, (200, 50), (225, 125), blue, -1)
cv2.imshow("Canvas", canvas)
cv2.waitKey(0)




본문 31장.




14번째 줄을 보면 cv2.rectangle 메소드를 사용한다. 이 메소드의 특징은 위에 있는 cv2.line과 동일하다는 것이다.
하지만 각각의 인자를 다시 한번 살펴보자.


첫번째 인자는 이미지를 그릴 공간이며 이 예제에서는 canvas가 된다. 두번째 인자는 직사각형의 시작 위치를 (x, y) 튜플로 넣어준다. 이 경우에 rectangle의 시작점은 (10, 10)으로 한다. 그 다음 우린 마지막 지점 (x,y) 지점을 직사각형으로 지정한다. 우린 60,60으로 직사각형 마지막 지점을 설정해서 결정된 영역은 50 x 50 픽셀이 된다. 마지막으로 마지막 인자는 당신이 그릴 직사각형의 색상이다.


우린 라인의 굵기와 마찬가지로 직사각형의 굵기를 조절할 수 있습니다. 18번째 줄을 보면 한가지 인자, 굵기가 추가가 되었다.
여기 우린 빨간 직사각형을 5픽셀 굵기로 50, 200 지점에서 200, 225 범위로 그릴거다. 여기까지 우린 오직 직사각형의 윤곽만 그렸다. 어떻게 이제 챔터4의 NumPy 배열 자르기 같은걸 사용해서 직사각형안을 채울수 있을까?




본문 32장.
그림 5.2: 간단한 과녁판을 cv2.circle 함수를 이용해서 그려보자.


간단하다. 그저 단순히 굵기의 부정 밸류만 넣으면 된다.(-1)


23번째 줄에 어떻게 속이 색으로 꽉찬 직사각형을 그릴 수 있는 명시되어 있다. 우린 파란색으로 200, 50 지점에서 225, 125까지의 직사각형을 그렸다. 굵기를 -1로 지정함으로써 우리 직사각형은 속이 파란색으로 꽉차게 된다.


축하합니다! 당신은 이제 직사각형을 원하는 색으로 그릴 수 있게 됐습니다. 다음 차례에는 우린 원을 그려볼겁니다.




5.2 CIRCLES


원을 그리는건 직사각형을 그리는것처럼 쉽습니다. 하지만 전달하는 인자가 조금 다릅니다. 그럼 다음으로 넘어가봅시다.




본문 33장.


26번째 줄을 보면 canvas를 공백으로 다시 만들었습니다. 직사각형은 모두 사라졌습니다!
우린 canvas를 청소하고 원들을 그릴겁니다.


27번째 줄을 보면 centerX와 centerY라는 두 변수가 있습니다. 이 두개의 변수는 이미지의 중앙 (x,y) 좌표를 나타냅니다. 우리는 NumPy 배열에서 도형의 중앙을 계산하고 절반으로 나눕니다. canvas의 높이는 canvas.shape[0]에서 찾을 수 있으며 넓이 역시 canvas.shape[1]에서 찾을 수 있습니다. 마지막으로 28번째 줄에서 흰색 픽셀을 지정합니다.


자 그러면 이제 원을 그려봅시다!


30번째 줄에는 0부터 150까지 25씩 반지름의 크기를 증가하는 반복문이 있습니다. 맨 처음 파라미터는 우리의 canvas, 우리가 원을 그릴 곳입니다. 그리고 우리는 원을 그릴 좌표를 지정해줍니다. 우리는 (centerX, centerY) 좌표를 지정했습니다. 이미지의 정중앙에서 원들이 생성될 겁니다. 세번째 인자는 바로 원의 반지름입니다. 마지막으로 원의 색상을 넘겨주면 됩니다.


본문 34장.
이번 경우는 흰색입니다.


33, 34번째 줄을 이용해서 이미지를 출력하고 키 입력을 대기합니다.


어떻게 이미지가 출력되나요?


그림 5.2를 보면 우리가 간단한 과녁을 그렸다는걸 알 수 있습니다. 정 가운데에 있는 점은 반지름이 0인 원입니다. 만약 원이 더 커지면 for 반복문의 반지름 사이즈를 증가시키면 됩니다.


나쁘지 않다. 하지만 이걸로 무엇을 할 수 있습니가?


자 그럼 몇몇의 추상적인 그림을 그려보자.


for i in xrange(0, 25):
radius = np.random.randint(5, high = 200)
color = np.random.randint(0, high = 256, size = (3,)).tolist()
pt = np.random.randint(0, high = 300, size = (2,))
cv2.circle(canvas, tuple(pt), radius, color, -1)


cv2.imshow("Canvas", canvas)
cv2.waitKey(0)




35번째 줄에서는 반복문을 시작합니다. 이번에는 반경의 크기를 반복하지 않겠습니다. - 대신에 우린 25가지의 랜덤한 원들을  NumPy의 랜덤값 기능이 있는 np.random.randint 함수를 통해 그릴겁니다.


랜덤 원을 그리기 위해서는 세가지 값을 생성해야 합니다. 원의 반지름, 원의 색깔,


본문 35장.
그림 5-3: 출력된 명작. 각 원들은 랜덤한 장소에 랜덤한 색깔로 표시됐음을 공지합니다.


그리고 원이 그려질 (x,y) 좌표입니다.


36번째 줄을 보면 우린 5에서 200 사이의 반지름을 선택했습니다. 이 값에 따라서 얼마나 큰 원이 그려질지 결정됩니다.


다음으로 37번째 줄에서 우린 랜덤한 색상을 설정했습니다. 이미 알다싶이 컬러는 RGB 픽셀, 세개의 값으로 이루어져 있습니다. 각각의 값은 0~255사이의 값입니다. 세개의 랜덤한 정수 밸류를 가지고 오기 위해서  NumPy 설명서의 따라 우린 size=(3,)라는 키워드로 인자를 전달해야 합니다.
본문 36장.
마지막으로 우린 원을 그리기 위해서 (x,y) 좌표가 필요합니다. 0~300 사이의 범위에 랜덤한 위치로 다시 한번 np.random.randint 함수를 통해 생성됩니다.


최종적으로 40번째 줄에는 반지름, 색상, 좌표를 사용해서 랜덤하게 원을 그리는 코드가 있습니다. 윤곽 뿐만 아니라 속까지 채우기 위해 굵기 부분을 -1로 설정했다는것에 주목할 필요가 있습니다.


42, 43번째 줄에서는 우리의 명작을 보여줍니다.


그림 5.3에서 작업한 내용을 볼 수 있습니다. 어떻게 각각의 원의 크기, 위치, 색상을 canvas에 표시됐는지 주목하세요.


이번 챕터에서는 OpenCV의 기본 함수를 사용해서 기본적인 그림을 그리는걸 소개했습니다.
우린 cv2.line, cv2.rectangle, cv2.circle 메소들을 통해 다양한 모양들을 그리는걸 체험해봤습니다.


이 함수들이 굉장히 기본적이고 쉽게 보이지만 당신이 이것들을 이해했는지 확인해보세요! 그것들은 책 뒤에 나올것들을 손 쉽게 사용할 수 있는 필수적인 과정입니다.


본문 37장. (영상 처리)
이제 굳건한 재단을 만들었으니 간단한 이미지 처리 기술을 배울 수 있습니다.


첫 번째로 우린 이미지 변형을 기본으로 배울겁니다. 변형, 회전, 사이즈 변경,, 플립핑 그리고 자르는거 까지.
그 다음 이미지 계산, 비트 연산, 그리고 제작이 포함 등 영상 처리에 다른 기술들을 살펴볼겁니다.


마지막으로 어떻게 이미지의 채널을 자르고, 합치고, 다시 복구할 수 있는지 확인해볼겁니다. 이번 챕터에서 OpenCV에서 지원하는 다양한 색상 공간과 각 색상 공간의 이점과 한계에 대해 설명합니다.


6.1 이미지 변환


이번 섹션에서는 기본 이미지 변환에 대해 설명합니다. 이것들은 가장 일반적인 기술입니다.당신이 이미지에 적용하는 회전, 사이즈 변경, 플리핑, 자르기 등이 포함됩니다. 이러한 기술들을 각각 자세히 살펴보겠습니다.




본문 38장.


이 함수들을 분명히 하고 넘아가세요! 저것들은 모든 컴퓨터 비전 영역에 중요한것들 입니다.


6.1.1 Translation


첫번째 함수는 바로 translation입니다. Translation은 이미지 x, y를 축으로 움직이는 작업입니다. translation을 이용하면 우리는 이미지를 위, 아래, 좌, 우로 움직이게 할 수 있습니다.


이 개념은 코드를 통해 더욱 잘 설명되어 있습니다.


import numpy as np
import argparse
import imutils
import cv2


ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", required = True,
help = "Path to the image")
args = vars(ap.parse_args())


image = cv2.imread(args["image"])
cv2.imshow("Original", image)


M = np.float32([[1, 0, 25], [0, 1, 50]])
shifted = cv2.warpAffine(image, M, (image.shape[1], image.shape[0]))
cv2.imshow("Shifted Down and Right", shifted)


M = np.float32([[1, 0, -50], [0, 1, -90]])
shifted = cv2.warpAffine(image, M, (image.shape[1], image.shape[0]))
cv2.imshow("Shifted Up and Left", shifted)
cv2.waitKey(0)


1-4번째 줄에는 필요한 패키지를 미리 임포트합니다. 이쯤에서 numpy, argparse, cv2는 느낌상 매우 흔하게 사용하는걸 알고 있을거다. 그러나 이번에는 새로운 패키지 imutils를 소개할려고 한다. 이 패키지는 Numpy와 OpenCV에 포함되어 있지 않는다. 이 라이브러리는 흔히 사용하는 변형, 회전, 사이즈 변경 메소드들을 제공해준다.




본문 39장.


필요한 패키지들을 모두 포함시킨 후 1-12번째 줄에서는 이미지를 로드할 수 있게 인자 파서를 작성합니다. 실질적으로 14-16번재 줄에서는 이미지 변형 작업이 이루어집니다. 가장 먼저 행렬 M을 정의합니다. 그런 후 행렬에다가 얼마만큼의 픽셀을 좌 혹은 우로 그리고 위 아래로 움직일지 명시하면 됩니다.


변형되는 행렬 M은 실수형의 배열입니다. - 이것은 중요합니다. 왜냐하면 OpenCV는 이 행렬을 실수형 타입으로 인식하기 때문입니다. 제일 첫번째 인자는 행렬 1, 0, tx 이며 tx는 좌 혹은 우로 움직일 픽셀의 값입니다. tx를 명시함으로써 가능한 만큼 이미지가 좌 또는 우로 움직이게 됩니다.


그런 후 두번째 행렬의 행인 [0, 1, ty],에서 ty는 이미지의 위 혹은 아래를 얼만큼 움직일지에 대한 픽셀 값입니다. ty를 명시함으로써 이미지는 위 혹은 아래로 움직일 것입니다.


표기법을 사용해서 14번째 줄에 표시된 tx = 25, ty = 50을 보면 이미지가 25만큼 우로, 50만큼 아래로 움직인다는 것을 알 수 있습니다.
본문 40장.


이제 드디어 우린 움직인 행렬을 가지고 있습니다. 실질적으로 픽셀을 움직이는 코드는 cv2.warpAffine 메소드를 사용한 15번째 줄입니다.
첫 번째 인자는 이동할 이미지이며, 두번째 인자는 움직일 픽셀 값을 행렬로 정의한 실수형 변수입니다. 마지막으로 이미지의 면적, 즉 넓이, 높이에 대한 정보를 기본적으로 제공해줘야 합니다. 16번째 줄에 imshow 함수를 통해서 우리가 작성한데로 이미지가 이동한걸 보여주고 있습니다.


그 다음 18-20번째 줄로 넘어와서, 이번에는 -50, -90 값으로 x, y축을 정의 했습니다. 만약 음수로 정의할 시 x축은 left, y축은 위를 향하게 됩니다.
이미지 시작 픽셀이 (0,0) 좌표라고 생각하면 x축은 + 될수록 오른쪽, y축은 + 될수록 아래, -는 그 반대라는걸 이해하실겁니다.

하지만 이렇게 손으로 일일이 이동할 행렬을 직접 만들고, cv2.warpAffine 메소드를 호출하는건 코드 낭비이며 당연히 유지보수도 힘들게 된다!


imutils.py라는 파일을 만들자. 이 파일에는 편의와 코드 효율성을 위해 기본적인 이미지 처리 함수가 저장될거다.


그 중 첫 번째 함수가 바로 위에서 배운 warpAffine이다.


import numpy as np
import cv2


def translate(image, x, y):
    M = np.float32([[1, 0, x], [0, 1, y]])
    shifted = cv2.warpAffine(image, M, (image.shape[1], image.shape[0]))
    return shifted




본문 41장.


위에 제작한 translation 메소드에 필요한 세개의 파라미터 : 움직일 이미지, x축, y축을 움직일 픽셀 값.


5번째 줄을 보면 translation 행렬 M이 정의되어 있다. 그리고 6번재 줄을 보면 실제로 이미지를 이동하는 warpAffine 함수가 호출되었고 마지막으로 8번째 줄에서는 행렬 M에 값만큼 이동된 이미지가 반환된다.


그러면 이제 이 메소드를 적용하고 이전 메소드와 비교해보자.


shifted = imutils.translate(image, 0, 100)
cv2.imshow("Shifted Down", shifted)
cv2.waitKey(0)


translate을 사용해서 편리하게 한줄만으로 이미지의 위치를 아래로 100 픽셀만큼 움직일 수 있었다.
더 나아가서 translate은 함수는 사용하기도 굉장히 쉽다. - 최적의 코드양, 함수 이름의 기반을 통해서 어떤 이미지 처리 작업이 수행되는지 편리하게 알 수 있습니다.


우리의 translation 실행 결과를 보자, 그림 6.1.에서 확인 가능하다. 원본 이미지는 좌측 상단에 있습니다. 우측 상단은 오른쪽으로 25 픽셀, 아래로 50픽셀 움직였으며, 그 다음 이미지는 50픽셀 왼쪽, 90픽셀 위로, 나머지 하나는 100 픽셀 아래로 움직인 이미지를 보여줍니다.


본문 42장.
그림 6.1: 좌측 상단: 원본 이미지, 우측 ~


본문 43장.


이번 장에서는 어떻게 이미지를 좌우, 상하 움직일 수 있는지 알아봤습니다. 다음 장에서는 이미지 회전에 대해 알아봅니다.


6.1.2 Rotation


 회전이란 : 임의에 각도만큼 이미지를 회전시킵니다. 이번 장에서는 어떻게 이미지를 회전할 수 있는가 알아볼겁니다. 우리는 임의에 각도를 이용해서 이미지를 회전시킬겁니다. 그 이후에는 다른 편리한 rotate 메소드를 제공하여 이미지를 쉽게 회전 시킬 수 있게 만들겁니다.
import numpy as np
import argparse
import imutils
import cv2


ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", required = True, help = "Path to the image")
args = vars(ap.parse_args())


image = cv2.imread(args["image"])
cv2.imshow("Original", image)


(h, w) = image.shape[:2]
center = (w / 2, h / 2)


M = cv2.getRotationMatrix2D(center, 45, 1.0)
rotated = cv2.warpAffine(image, M, (w, h))
cv2.imshow("Rotated by 45 Degrees", rotated)


M = cv2.getRotationMatrix2D(center, -90, 1.0)
rotated = cv2.warpAffine(image, M, (w, h))
cv2.imshow("Rotated by -90 Degrees", rotated)
cv2.waitKey(0)
본문 44장.


1-4번째 줄은 필요한 패키지를 임포트합니다. 당신은 무조건 imutils를 적으셔야합니다. 다시 한번 우리는 간편한 메소드를 정의해서 삶을 좀 더 윤택하게 할겁니다.


6-12번째 줄은 인자 파서를 제작합니다. 첫번째 인자는 무조건적으로 사용할 이미지 경로가 전달되야 합니다.


이미지를 회전 시킬때는 지정된 위치 정보가 필요합니다. 대부분 이미지의 정중앙을 기준으로 이미지를 회전시킵니다. 그러나 OpenCV는 특정 위치를 회전시키는게 가능합니다. 계속 진행해봅시다. 14, 15번째 줄은 이미지의 넓이와 높이를 가져와 절반으로 나누는데 사용됩니다.


행렬을 정의해서 이미지를 이동한거 처럼 이미지를 회전시킬 행렬을 제작합니다. 기본적으로 사용되는 NumPy 기반 행렬 대신에, cv2.getRotationMatrix2D 메소드 호출을 통한 행렬을 사용합니다. 17번째 줄처럼


cv2.getRotationMatrix2D 함수는 세개의 인자가 필요합니다. : 회전할 이미지의 지점(기본적으로 이미지의 정중앙을 나타냅니다.) 특정 값을 정의했을 때 그 값만큼 이미지가 회전될겁니다. 위 예제에서는 45 각도만큼 이미지를 회전시킬 예정입니다. 마지막 인자는 바로 이미지의 크기입니다. 우린 이미지 사이즈를 아직 변경하지 않을거기 때문에 이 부분은 무시해도 됩니다. 그치만 이 부분은 특정 실수값으로 지정할 수 있습니다. 1.0을 정의한다는것은 같은 크기에 이미지를 사용하겠다는 말과 같습니다.
그러나 만약 2.0 두배의 크기나 0.5 같은 절반의 크기로 이미지를 지정 할 수도 있습니다.




본문 45장.


cv2.getRotationMatrix2D 함수를 통해서 회전시킬 정보가 담긴 행렬 M을 가지고 있습니다. 이 행렬을 이용해서 warpAffine 메소드를 통해 이미지를 회전 시킬수 있습니다.(18번째 줄) 첫 번째 인자는 회전시킬 이미지입니다. 두번째는 회전 정보가 담긴 행렬, 세번째는 이미지의 크기 정보입니다. 19번째 줄을 보면 이미지를 45각도로 회전시키는걸 확인할 수 있으며 그림으로는 6.2 우측 상단에 해당합니다.


자 쉴 시간은 없습니다. 이제 회전과 관련된 다른 코드를 살펴볼 차례입니다.


21-23번째 줄을 보면 다른 회전이 수행되고 있습니다. 17-19 코드에서는 45도가 아닌 -90도 각도를 주었습니다. 그림 6.2를 보면 좌측 하단에 있스빈다.


이미지 translation 메소드를 만든것처럼 이번에도 rotate 메소드를 imutils.py에 작성하겠습니다.




def rotate(image, angle, center = None, scale = 1.0):
    (h, w) = image.shape[:2]
    if center is None:
        center = (w / 2, h / 2)


    M = cv2.getRotationMatrix2D(center, angle, scale)
    rotated = cv2.warpAffine(image, M, (w, h))


    return rotated




본문 46장.


그림 6.2: 회전시킨 이미지들이 표시됨.




본문 47장.


rotate 함수에는 총 네개의 인자가 필요합니다. 첫 번째는 바로 이미지입니다. 두 번째는 이미지를 회전 시킬 각도이며, 나머지는 선택적인 파라미터로 center와, scale 입니다. center는 회전 시키길 원하는 이미지의 특정 포인트입니다. 만약 기본적으로 None이 제공됐을 때 메소드는 자동으로 30-31 라인으로 이미지의 정중앙을 포인트로 잡습니다. 마지막으로 scale 파라미터에는 바로 이미지의 사이즈가 들어갑니다. 만약 특정 사이즈를 지정하고 싶을 때는 1.0 을 기준으로 +, - 하면 됩니다.


실질적으로 이미지 회전을 시키는 코드는 33, 34번째 줄입니다. 회전 행렬 M을 선언하고 이미지의 전달하면서 이미지를 회전시킬 수 있게 됩니다.


그럼 우리가 만든 rotate 함수를 직접 적용해봅시다.


rotated = imutils.rotate(image, 180)
cv2.imshow("Rotated by 180 Degrees", rotated)
cv2.waitKey(0)


이번에는 이미지를 180도 회전시켰습니다. 그림 6.2를 보면 T-Rex가 위 아래로 완전히 뒤집힌게 보입니다. 이 코드는 cv2.getRotationMatrix2D와 cv2.warpAffine을 기반으로 더 쉽고 편리하게 이미지를 회전시킬 수 있게 해줍니다.




본문 48장.


6.1.3 Resizing


지금까지 우리는 두개의 이미지 변형을 살펴봤습니다. : 이동, 회전.
이번에는 어떻게 이미지 사이즈를 재조정할 수 있는지 알아보겠습니다. 또한 imutils.py에 마지막 메소드를 정의해서 손 쉽게 이미지 크기를 조절할 수 있도록 할겁니다.


혹시 놀랍지 않은가요, 우린 cv2.resize 함수를 이미지 크기 조절을 위해 사용할겁니다. 하지만 한가지 꼭 알아두어야 하는건 함수를 사용할 때 이미지의 영상비는 꼭 유지되어야 합니다. 더 자세히 알아보기 전에 일단 아래 예제 코드를 확인해봅시다.




import numpy as np
import argparse
import imutils
import cv2


ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", required = True, help = "Path to the image")
args = vars(ap.parse_args())


image = cv2.imread(args["image"])
cv2.imshow("Original", image)


r = 150.0 / image.shape[1]
dim = (150, int(image.shape[0] * r))


resized = cv2.resize(image, dim, interpolation = cv2.INTER_AREA)
cv2.imshow("Resize (Width)", resized)
cv2.waitKey(0)


1-12번째 코드는 너무 많이봐서 이제는 귀찮을 정도입니다. 패키지를 임포트하고, 인자 파서를 세팅하고, 뿌려질 이미지를 세팅합니다.


본문 49장.


이 코드에서 제일 흥미로운 코드는 바로 14, 15번째 줄부터 입니다. 이미지 크기를 조절하면 우린 이미지의 해상도 비율을 유지해야 합니다. 해상도 비율은 넓이와 높이에 에 비례합니다. 만약 이미지 비율을 고려하지 않는다면 크기가 변경된 이미지의 모습은 말끔하지 못할겁니다.


이미지 비율을 계산하는 코드는 14번째 줄입니다. 코드에 이 줄에서는 새로운 이미지의 넓이를 150 픽셀로 고정했습니다. 이에 맞는 비율을 맞추기 위해서 ㄴ기존 넓이를 150으로 나누고 비율 변수 r을 간단히 정의했습니다.


이제 우린 이미지의 비율을 알고 있습니다. 15번째 줄을 통해서 새로운 이미지 크기를 계산할 수 있습니다. 다시 한번 넓이는 150 픽셀이며 높이는 원래 높이와 이미지 비율을 계산하면 됩니다.


실제 이미지는 17번째 줄에서 나타나게 됩니다. 첫번째는 당연하게도 이미지 변수이며, 두번째에는 새로운 이미지 크기, 세번째는 interpolation 함수입니다. 이건 바로 이미지를 정확히 사이즈를 조절하기 위해서 호출되는 알고리즘입니다. 기본적으로 cv2.INTER_AREA를 포함하게 되면 사이즈를 재조절할 때 가장 정확한 값을 얻을 수 있습니다 다른 옵션으로는 cv2.INTER_LINEAR, cv2.INTER_CUBIC, cv2.INTER_NEAREST가 있습니다.


본문 50장.


마지막으로 18번째 줄에서 이미지를 재조절 했습니다.




--


계속 같은 패턴으로 영작이 되어 있어서 더 이상 번역 없이 빠르게 독해하는게 더 좋을거 같아 여기까지 작성함.
